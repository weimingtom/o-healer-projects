<?xml version="1.0" encoding="UTF-8"?>
<mx:Application
	xmlns:mx="http://www.adobe.com/2006/mxml"
	xmlns:comp="*"
	width = "100%"
	height = "100%"
	applicationComplete="init()"
>
	<!--Script-->
	<mx:Script>
		<![CDATA[
/*
			以下のライブラリを使っています
			・as3yaml
			　・http://code.google.com/p/as3yaml/
			・AS3 Zip Library
			　・http://nochump.com/blog/archives/15
*/

			import mx.graphics.codec.*;

			import org.as3yaml.*;

			import nochump.util.zip.*;

			import mx.controls.*;
			import mx.events.*;

			//プリロード画像（とか色パレットをまとめたZip）
			[Embed(source = "Result.zip", mimeType="application/octet-stream")]
			 public var PreloadZip:Class;
/*
			//トレース対象
			[Embed(source='chara02_b_side.png')]
			 private static var Bitmap_Trace_Color: Class;
//*/
			//トレース用プリロード画像
			[Embed(source='trace.png')]
			 private static var Bitmap_Trace: Class;
			
/*
			//模写対象の追加
			[Embed(source='chara1_ci.png')]
			 private static var Bitmap_Sample_Color: Class;
			[Embed(source='chara1_si.png')]
			 private static var Bitmap_Sample_Shade: Class;
//*/
//*
			//chara1
			public var info_color:Array = [
				{H:0.8/6.0,	S:5.0/6.0,	L:3.5/6.0,	A:1},//Hair
				{H:3.0/6.0,	S:5.0/6.0,	L:2.5/6.0,	A:1},//Eye
				{H:0.5/6.0,	S:1.5/6.0,	L:4.5/6.0,	A:1},//Skin
				{H:6.0/6.0,	S:0.0/6.0,	L:3.5/6.0,	A:1},//(no use)
				{H:3.5/6.0,	S:5.0/6.0,	L:3.5/6.0,	A:1},//Armor : Main
				{H:2.0/6.0,	S:0.5/6.0,	L:3.5/6.0,	A:1},//Armor : Line
				{H:2.0/6.0,	S:5.0/6.0,	L:2.0/6.0,	A:1},//Manteau
				{H:5.5/6.0,	S:5.0/6.0,	L:2.0/6.0,	A:1},//Gauntlet
				{H:6.0/6.0,	S:0.0/6.0,	L:0.0/6.0,	A:0} //(Trans)
			];
//*/
/*
			//chara2
			public var info_color:Array = [
				{H:0.0/6.0,	S:5.0/6.0,	L:3.0/6.0,	A:1},//Hair
				{H:1.0/6.0,	S:5.0/6.0,	L:3.0/6.0,	A:1},//Accessory
				{H:0.5/6.0,	S:1.5/6.0,	L:4.5/6.0,	A:1},//Skin
				{H:4.0/6.0,	S:0.0/6.0,	L:2.5/6.0,	A:1},//Eye
				{H:2.0/6.0,	S:5.0/6.0,	L:2.5/6.0,	A:1},//Cloth : Main
				{H:1.0/6.0,	S:5.0/6.0,	L:2.5/6.0,	A:1},//Cloth : Line
				{H:3.0/6.0,	S:5.0/6.0,	L:2.5/6.0,	A:1},//Cloth : Line2
				{H:0.5/6.0,	S:5.0/6.0,	L:2.0/6.0,	A:1},//Leg
				{H:6.0/6.0,	S:0.0/6.0,	L:0.0/6.0,	A:0} //(Trans)
			];
//*/

			public var info_shade:Array = [
				{H:0, S:0, L:1, A:0.6},
				{H:0, S:0, L:0, A:0.6}
			];


			//Draw Type
			static public const DRAW_TYPE_DOT:int	= 0;
			static public const DRAW_TYPE_FILL:int	= 1;
			[Bindable]
			private var ComboData_Draw:Array = [{label:"Dot",data:DRAW_TYPE_DOT},{label:"Fill",data:DRAW_TYPE_FILL}];

			//Cursor Type
			[Bindable]
			private var ComboData_Cursor:Array = [
				{label:"Normal",		data:Canvas_Zoom.CURSOR_MODE_NORMAL},
				{label:"MirrorX",		data:Canvas_Zoom.CURSOR_MODE_MIRROR_X_16_16},
				{label:"MirrorX15",		data:Canvas_Zoom.CURSOR_MODE_MIRROR_X_15_1_15},
				{label:"MirrorY",		data:Canvas_Zoom.CURSOR_MODE_MIRROR_Y_16_16},
				{label:"MirrorY15",		data:Canvas_Zoom.CURSOR_MODE_MIRROR_Y_15_1_15},
				{label:"MirrorXY",		data:Canvas_Zoom.CURSOR_MODE_MIRROR_XY_16_16},
				{label:"MirrorXY15",	data:Canvas_Zoom.CURSOR_MODE_MIRROR_XY_15_1_15}
			];


			public static const PaletteCenterIndex:int = (Palette_Color.PALETTE_NUM-1)/2;
			public static const pos_zero:Point = new Point(0,0);

			//最初のロード完了時の初期化
			private function init():void{
				//接続：カーソル
				{
					//color
					palette_c_color.onCursorChange  = palette_hl_color.setCursorIndex;//カラーパレットで色を選んだら、HLもそれに合わせる
					palette_hl_color.onCursorChange = palette_s_color.setCursorIndex;//...
					palette_s_color.onCursorChange  = palette_a_color.setCursorIndex;

					//shade
					palette_c_shade.onCursorChange  = function(in_Index:int, in_InputColor:uint):void{
						//パレットのIndex→光(0)と陰(1)のマッピング
						if(in_Index < PaletteCenterIndex){
							palette_hl_shade.setCursorIndex(0);
						}
						if(in_Index > PaletteCenterIndex){
							palette_hl_shade.setCursorIndex(1);
						}
						//中央のやつでは切り替わらない
					};
					palette_hl_shade.onCursorChange = palette_s_shade.setCursorIndex;//他は色と同じ
					palette_s_shade.onCursorChange  = palette_a_shade.setCursorIndex;
				}

				//接続：色変更
				{
					//color
					palette_hl_color.onOutputChange = palette_s_color.onInputChange;//HLで色変更が行われたら、Sの色変更も行う
					palette_s_color.onOutputChange  = palette_a_color.onInputChange;//...
					palette_a_color.onOutputChange  = palette_c_color.onInputChange;
					palette_c_color.onOutputChange  = function(i:uint):void{
						index_to_color(canvas_color, palette_c_color);//カラーパレットが変更されたら、キャンバスを更新
						merge_to_result_all();//合成キャンバス全体も更新
					}

					//shade
					palette_hl_shade.onOutputChange = palette_s_shade.onInputChange;//HLで色変更が行われたら、Sの色変更も行う
					palette_s_shade.onOutputChange  = palette_a_shade.onInputChange;//...
					palette_a_shade.onOutputChange  = function(in_InputColor:uint):void{
						//光陰の色の変更→パレットの光陰をそれぞれ再計算

						//色変更
						color_to_shade(palette_a_shade.m_CursorIndex, in_InputColor);

						//キャンバスも変更
						index_to_color(canvas_shade, palette_c_shade);

						//合成キャンバス全体も更新
						merge_to_result_all();
					}
//					palette_c_shade.onOutputChange  = function(i:uint):void{index_to_color(canvas_shade, palette_c_shade);}//...
				}

				//接続：キャンバス<=>合成キャンバス
				{
					//合成キャンバス => 各キャンバス
					canvas_result.onSelected = function():void{
						//result => color
						canvas_color.m_BitmapData_Index.copyPixels(
							canvas_result.Get_BitmapData_Index_Color(),
							canvas_color.m_BitmapData_Index.rect,
							pos_zero
						);

						//result => shade
						canvas_shade.m_BitmapData_Index.copyPixels(
							canvas_result.Get_BitmapData_Index_Shade(),
							canvas_shade.m_BitmapData_Index.rect,
							pos_zero
						);

						//Index => Color
						index_to_color(canvas_color, palette_c_color);
						index_to_color(canvas_shade, palette_c_shade);

						//合成キャンバスも更新
						merge_to_result();

						//全体用トレース画像があればそれをロード
						{
							var trace_bmp_data:BitmapData = canvas_result.GetTraceBitmapData();
							if(trace_bmp_data){
								canvas_color.m_Bitmap_Trace.bitmapData = trace_bmp_data;
							}else{
								//ない場合はクリアしても良いか
							}
						}
					}

					//各キャンバス => 合成キャンバス
					//!!すでに他のところに埋め込まれている
				}

				//接続：初期化
				{
					//color
					palette_hl_color.onReset = palette_s_color.reset;
					palette_s_color.onReset  = palette_a_color.reset;
					palette_a_color.onReset  = palette_c_color.reset;

					//shade
					palette_hl_shade.onReset = palette_s_shade.reset;
					palette_s_shade.onReset  = palette_a_shade.reset;
					palette_a_shade.onReset  = function(in_Info:Array, in_InputColor:Array):void{
						//
						color_to_shade(0, in_InputColor[0]);
						color_to_shade(1, in_InputColor[1]);

						//キャンバスも変更
						index_to_color(canvas_shade, palette_c_shade);
					}
				}

				//キャンバスの初期化
				{
					//color
					canvas_color.clearIndex(Palette_Color.PALETTE_NUM-1);//透明色のはずのパレットIndexで塗りつぶす

					//shade
					canvas_shade.clearIndex(PaletteCenterIndex);//透明色のはずのパレットIndexで塗りつぶす

					//result
					canvas_result.ClearIndex_Color(Palette_Color.PALETTE_NUM-1);
					canvas_result.ClearIndex_Shade(PaletteCenterIndex);
				}

				//パレットの初期化
				{
					//color
					palette_hl_color.reset(info_color);//onReset => resetの連鎖で初期化

					//shade
					palette_hl_shade.reset(info_shade);//onReset => resetの連鎖で初期化

					//合成キャンバスも更新
					merge_to_result();
				}

				//初期カーソル位置
				{
					palette_c_shade.setCursorIndex(PaletteCenterIndex);
				}


				//Sync Cursor
				{
					canvas_color.addEventListener_MouseMove(sync_cursor);
					canvas_shade.addEventListener_MouseMove(sync_cursor);
				}

				//DrawIndex Dot
				{
/*
					var draw_dot:Function = function(in_X:int, in_Y:int, in_OldX:int, in_OldY:int):void{
						var in_Canvas:Canvas_Zoom = canvas_color;

						//各カーソルに対してDraw
						in_Canvas.m_Cursor.forEach(function(cursor:*, index:int, arr:Array):void{
							//Check
							{
								if(! cursor.visible){
									return;//表示されていないカーソルの分は描かない
								}
							}

							var dst_x:int;
							var dst_y:int;
							{
								dst_x = cursor.x/Canvas_Zoom.SIZE_RATIO;
								dst_y = cursor.y/Canvas_Zoom.SIZE_RATIO;
							}

							//Draw
							{
								m_DrawFunc(
								);
								in_Canvas.m_BitmapData_Index.setPixel(
									dst_x,
									dst_y,
									palette_c_color.m_CursorIndex
								);
							}
						});

						//Indexを変更したので、表示画像も更新
						{
							index_to_color(in_Canvas);
						}
					};
					var draw_dot_forDown:Function = function(in_X:int, in_Y:int):void{
						draw_dot(in_X, in_Y, in_X, in_Y);
					};
/*/
					//Param
					var src_x:int = 0;
					var src_y:int = 0;
					var dst_x:int = 0;
					var dst_y:int = 0;
					var ori_bitmap:BitmapData;

					//Down
					var onMouseDown:Function = function(in_Canvas:Canvas_Zoom, in_Palette:Palette_Color):Function{
						return function(in_X:int, in_Y:int):void{
							//Param
							{
								src_x = in_X;
								src_y = in_Y;
								dst_x = in_X;
								dst_y = in_Y;

								ori_bitmap = in_Canvas.m_BitmapData_Index.clone();
							}

							//Draw Index
							{
								m_DrawFunc(
									in_Palette.m_CursorIndex,//in_Color:uint;
									src_x,//in_SrcX:int,
									src_y,//in_SrcY:int,
									dst_x,//in_DstX:int,
									dst_y,//in_DstY:int,
									ori_bitmap,//in_Bitmap_Main:BitmapData,
									in_Canvas.m_BitmapData_Index,//in_Bitmap_Preview:BitmapData,
									true,//in_IsStart:Boolean,
									false//in_IsEnd:Boolean,
								);
							}

							//Index => Color
							{
								index_to_color(in_Canvas, in_Palette);
							}

							//Color => Result
							{
								merge_to_result();
							}
						}
					}

					//Move
					var onMouseMove:Function = function(in_Canvas:Canvas_Zoom, in_Palette:Palette_Color):Function{
						return function(in_X:int, in_Y:int):void{
							//Param
							{
								dst_x = in_X;
								dst_y = in_Y;
							}

							//clear
							{
								in_Canvas.m_BitmapData_Index.copyPixels(ori_bitmap, ori_bitmap.rect, pos_zero);
							}

							//Draw Index
							{
								m_DrawFunc(
									in_Palette.m_CursorIndex,//in_Color:uint;
									src_x,//in_SrcX:int,
									src_y,//in_SrcY:int,
									dst_x,//in_DstX:int,
									dst_y,//in_DstY:int,
									ori_bitmap,//in_Bitmap_Main:BitmapData,
									in_Canvas.m_BitmapData_Index,//in_Bitmap_Preview:BitmapData,
									false,//in_IsStart:Boolean,
									false//in_IsEnd:Boolean,
								);
							}

							//Index => Color
							{
								index_to_color(in_Canvas, in_Palette);
							}

							//Color => Result
							{
								merge_to_result();
							}
						}
					}

					//Up
					var onMouseUp:Function = function(in_Canvas:Canvas_Zoom, in_Palette:Palette_Color):Function{
						return function(in_X:int, in_Y:int):void{
							//Param
							{
								dst_x = in_X;
								dst_y = in_Y;
							}

							//clear
							{
								in_Canvas.m_BitmapData_Index.copyPixels(ori_bitmap, ori_bitmap.rect, pos_zero);
							}

							//Draw Index
							{
								m_DrawFunc(
									in_Palette.m_CursorIndex,//in_Color:uint;
									src_x,//in_SrcX:int,
									src_y,//in_SrcY:int,
									dst_x,//in_DstX:int,
									dst_y,//in_DstY:int,
									in_Canvas.m_BitmapData_Index,//in_Bitmap_Main:BitmapData,
									ori_bitmap,//in_Bitmap_Preview:BitmapData,
									false,//in_IsStart:Boolean,
									true//in_IsEnd:Boolean,
								);
							}

							//Index => Color
							{
								index_to_color(in_Canvas, in_Palette);
							}

							//Color => Result
							{
								merge_to_result();
							}

							//履歴に追加
							{
								//ちょっと特殊だが
								if(in_Canvas == canvas_color){
									AddHistory_C();
								}
								if(in_Canvas == canvas_shade){
									AddHistory_S();
								}
							}
						}
					}
//*/

					canvas_color.addEventListener_MouseDown(onMouseDown(canvas_color, palette_c_color));
					canvas_color.addEventListener_MouseMove_WithDown(onMouseMove(canvas_color, palette_c_color));
					canvas_color.addEventListener_MouseUp(onMouseUp(canvas_color, palette_c_color));

					canvas_shade.addEventListener_MouseDown(onMouseDown(canvas_shade, palette_c_shade));
					canvas_shade.addEventListener_MouseMove_WithDown(onMouseMove(canvas_shade, palette_c_shade));
					canvas_shade.addEventListener_MouseUp(onMouseUp(canvas_shade, palette_c_shade));
				}


				//キャンバス用のボックスサイズの設定
				{
					box_canvas_color.width  = Canvas_Zoom.SIZE_W + box_canvas_color.verticalScrollBar.width;
					box_canvas_color.height = Canvas_Zoom.SIZE_H + box_canvas_color.horizontalScrollBar.height;

					box_canvas_shade.width  = Canvas_Zoom.SIZE_W + box_canvas_shade.verticalScrollBar.width;
					box_canvas_shade.height = Canvas_Zoom.SIZE_H + box_canvas_shade.horizontalScrollBar.height;
				}
				//それに合わせて履歴も
				{
					history_color.width = box_canvas_color.width;
					history_shade.width = box_canvas_shade.width;
				}

				//画像などのプリロード
				{
					Load_FromZip(new PreloadZip());
				}
/*
				//トレース画像のプリロード
				{
					var trace_bmp_data:BitmapData = new BitmapData(24*3, 32*4, true, 0x00000000);
					trace_bmp_data.draw(new Bitmap_Trace());
					Trace_Set(trace_bmp_data);
				}
//*/
			}

			//描画関数
			public var m_DrawFunc:Function = Draw_Dot.draw;
			//描画関数の切り替え
			public function Canvas_ChangeDrawType(in_Index:int):void{
				switch(in_Index){
				case DRAW_TYPE_DOT:
					m_DrawFunc = Draw_Dot.draw;
					break;
				case DRAW_TYPE_FILL:
					m_DrawFunc = Draw_Fill.draw;
					break;
				}
			}


			//カーソル

			//同期
			public function sync_cursor(in_X:int, in_Y:int):void{
				//Check Range
				{
					if(in_X < 0 || Canvas_Zoom.DOT_NUM <= in_X){
						return;
					}
					if(in_Y < 0 || Canvas_Zoom.DOT_NUM <= in_Y){
						return;
					}
				}

				//Sync Cursor
				{
					canvas_color.setCursorPos(in_X, in_Y);
					canvas_shade.setCursorPos(in_X, in_Y);
				}
			}

			//モード変更
			public function Canvas_SetCursorMode(in_Mode:int):void{
				canvas_color.setCursorMode(in_Mode);
				canvas_shade.setCursorMode(in_Mode);

				//変更の反映（あまり美しくない）
				sync_cursor(canvas_color.m_Cursor[0].x / Canvas_Zoom.SIZE_RATIO, canvas_color.m_Cursor[0].y / Canvas_Zoom.SIZE_RATIO);
			}


			//カラーパレットのIndexで描かれた画像を、実際の色に変換して表示
			public function index_to_color(in_Canvas:Canvas_Zoom, in_Palette:Palette_Color):void{
				for(var x:int = 0; x < Canvas_Zoom.DOT_NUM; x++){
					for(var y:int = 0; y < Canvas_Zoom.DOT_NUM; y++){
						var index:int = in_Canvas.m_BitmapData_Index.getPixel(x, y);
						var color:uint = in_Palette.GetColor(index);
						in_Canvas.m_BitmapData.setPixel32(x, y, color);
					}
				}
			}

			//色キャンバス＋光陰キャンバス => 合成キャンバス
			public function merge_to_result():void{
				canvas_result.Redraw(
					canvas_color.m_BitmapData,
					canvas_shade.m_BitmapData,
					canvas_color.m_BitmapData_Index,
					canvas_shade.m_BitmapData_Index
				);
			}

			//
			public function merge_to_result_all():void{
				canvas_result.Refresh(
					palette_c_color,
					palette_c_shade
				);
			}


			//光陰パレット用の「カラーピッカー→カラーパレット」部分の処理
			public function color_to_shade(in_Index:int, in_Color:uint):void{
				//基本の色データ
				var rgb:uint = in_Color & 0x00FFFFFF;
				var a_ori:uint = (in_Color >> 24) & 0xFF;

				var a:uint;
				var i:int;

				switch(in_Index){
				case 0://光
					for(i = 0; i < PaletteCenterIndex; i++){
						a = a_ori * (PaletteCenterIndex-i)/PaletteCenterIndex;
						palette_c_shade.SetColor(i, (a << 24) | (rgb));
					}
					break;
				case 1://陰
					for(i = 0; i < PaletteCenterIndex; i++){
						a = a_ori * (PaletteCenterIndex-i)/PaletteCenterIndex;
						palette_c_shade.SetColor(Palette_Color.PALETTE_NUM-1 - i, (a << 24) | (rgb));
					}
					break;
				}
			}



			//カラーピッカー部分の開閉
			public function OpenClose_Color():void{
				if(area_color_picker.width == 0){
					//Close => Open

					//Open
					area_color_picker.percentWidth = 100;

					//Label
					open_close_button_color.label = "←閉じる";
				}else{
					//Open => Close

					//Close
					area_color_picker.width = 0;

					//Label
					open_close_button_color.label = "色調整";
				}
			}
			public function OpenClose_Shade():void{
				if(area_shade_picker.width == 0){
					//Close => Open

					//Open
					area_shade_picker.percentWidth = 100;

					//Label
					open_close_button_shade.label = "→閉じる";
				}else{
					//Open => Close

					//Close
					area_shade_picker.width = 0;

					//Label
					open_close_button_shade.label = "光陰調整";
				}
			}


			//スクロール
			public function ScrollBitmap(in_MoveX:int, in_MoveY:int):void{
				//スクロール
				canvas_color.scroll(in_MoveX, in_MoveY);
				canvas_shade.scroll(in_MoveX, in_MoveY);

				//本当は上のスクロールに統合してしまいたい
				index_to_color(canvas_color, palette_c_color);
				index_to_color(canvas_shade, palette_c_shade);

				//合成画像も更新
				merge_to_result();
			}

			//反転
			public function ReverseBitmap():void{
				//今のところ左右反転しか使わないのでそれだけ
				canvas_color.reverse();
				canvas_shade.reverse();

				//本当は上のスクロールに統合してしまいたい
				index_to_color(canvas_color, palette_c_color);
				index_to_color(canvas_shade, palette_c_shade);

				//合成画像も更新
				merge_to_result();
			}


			//Draw View => Save View

			private function Copy_Ori2Save_Palette_C():void{
				var num:int = Palette_Color.PALETTE_NUM;

				for(var index:int = 0; index < num; index++){
					var color:uint = palette_c_color.GetColor(index);
					save_palette_c_color.SetColor(index, color);
				}
			}

			private function Copy_Ori2Save_Palette_S():void{
				var num:int = Palette_Color.PALETTE_NUM;

				for(var index:int = 0; index < num; index++){
					var color:uint = palette_c_shade.GetColor(index);
					save_palette_c_shade.SetColor(index, color);
				}
			}

			private function Copy_Ori2Save_Canvas_C():void{
				save_canvas_color.m_Bitmap.bitmapData = canvas_color.m_BitmapData.clone();
			}

			private function Copy_Ori2Save_Canvas_S():void{
				save_canvas_shade.m_Bitmap.bitmapData = canvas_shade.m_BitmapData.clone();
			}

			private function Copy_Ori2Save_Canvas_Result():void{
				save_canvas_result.m_Bitmap_Anim.bitmapData = canvas_result.m_BitmapData_Anim.clone();
			}

			//セーブ画面でのResultのカーソル選択→各キャンバスに反映
			private function onSaveCanvasSelected():void{
				//元のResultをまず変更
				canvas_result.m_CursorIndex = save_canvas_result.m_CursorIndex;
				canvas_result.RefreshCursor();

				//そして元の画面でそれを反映
				canvas_result.onSelected();

				//そしてそれをコピーに持ってくる
				Copy_Ori2Save_Canvas_C();
				Copy_Ori2Save_Canvas_S();
//				Copy_Ori2Save_Palette_C();
//				Copy_Ori2Save_Palette_S();
//				Copy_Ori2Save_Canvas_Result();
			}

			//見た目だけのコピー
			private function CopyGraphic_CanvasZoom(in_SrcCanvas:Canvas_Zoom, in_DstCanvas:Canvas_Zoom):void{
				in_DstCanvas.m_Bitmap.bitmapData = in_SrcCanvas.m_BitmapData.clone();
			}
			private function CopyGraphic_CanvasResult(in_SrcCanvas:Canvas_Result, in_DstCanvas:Canvas_Result):void{
				in_DstCanvas.m_Bitmap_Anim.bitmapData = in_SrcCanvas.m_BitmapData_Anim.clone();
			}


			//Drawed : canvas_resultから同じcanvas_resultへのコピー
			private function Copy_SrcIndex_to_DstIndex(in_SrcIndex:int, in_DstIndex:int):void{
				//Check
				{
					if(in_SrcIndex == in_DstIndex){
						return;//同じところなら更新しない
					}
				}

				//Copy
				{
					//Index : Color
					canvas_result.m_BitmapData_Index_Anim_Color[in_DstIndex] = canvas_result.m_BitmapData_Index_Anim_Color[in_SrcIndex].clone();
					//Index : Shade
					canvas_result.m_BitmapData_Index_Anim_Shade[in_DstIndex] = canvas_result.m_BitmapData_Index_Anim_Shade[in_SrcIndex].clone();
				}

				//Refresh
				{
					canvas_result.Refresh(
						palette_c_color,
						palette_c_shade
					);
				}

				//今選択中のものを変更した場合、色キャンバスなども更新
				{
					if(in_DstIndex == canvas_result.m_CursorIndex){
						canvas_result.onSelected();
					}
				}
			}


			//Draw View => TTrace View

			private function Copy_Ori2Trace():void{
				canvas_result_trace.m_Bitmap_Trace.bitmapData = canvas_result.m_Bitmap_Trace.bitmapData;//.clone()でも可
			}



			//==History==

			//履歴のリセット
			private function ResetHistory_C():void{
				history_color.removeAllChildren();
			}
			private function ResetHistory_S():void{
				history_shade.removeAllChildren();
			}

			//今のグラフィックを履歴に追加する
			private function AddHistory_C():void{
				var img:Image = new Image();
				{//見た目
					img.addChild(new Bitmap(canvas_color.m_BitmapData.clone()));
					img.width  = Canvas_Zoom.DOT_NUM;
					img.height = Canvas_Zoom.DOT_NUM;
				}

				{//Event
					var bmp_data_index:BitmapData = canvas_color.m_BitmapData_Index.clone();

					//クリックされたら対応する状態に戻す
					img.addEventListener(
						MouseEvent.MOUSE_DOWN,
						function(e:MouseEvent):void{
							canvas_color.m_BitmapData_Index.draw(bmp_data_index);
							index_to_color(canvas_color, palette_c_color);//キャンバスの表示部分を更新
							merge_to_result_all();//合成キャンバス全体も更新
						}
					);

					//スクロールバーを右端に寄せる
					img.addEventListener(
						FlexEvent.CREATION_COMPLETE,//登録完了時に実行
						function(e:Event):void{
							history_color.horizontalScrollPosition = history_color.horizontalScrollBar.maxScrollPosition;
						}
					);
				}

				history_color.addChild(img);
			}
			private function AddHistory_S():void{
				var img:Image = new Image();
				{//見た目
					img.addChild(new Bitmap(canvas_shade.m_BitmapData.clone()));
					img.width  = Canvas_Zoom.DOT_NUM;
					img.height = Canvas_Zoom.DOT_NUM;
				}

				{//Event
					var bmp_data_index:BitmapData = canvas_shade.m_BitmapData_Index.clone();

					//クリックされたら対応する状態に戻す
					img.addEventListener(
						MouseEvent.MOUSE_DOWN,
						function(e:MouseEvent):void{
							canvas_shade.m_BitmapData_Index.draw(bmp_data_index);
							index_to_color(canvas_shade, palette_c_shade);//キャンバスの表示部分を更新
							merge_to_result_all();//合成キャンバス全体も更新
						}
					);

					//スクロールバーを右端に寄せる
					img.addEventListener(
						FlexEvent.CREATION_COMPLETE,//登録完了時に実行
						function(e:Event):void{
							history_shade.horizontalScrollPosition = history_shade.horizontalScrollBar.maxScrollPosition;
						}
					);
				}

				history_shade.addChild(img);
			}


			//==Save & Load==

			//Save : All
			private function Save_All():void{
				//Zipで一通りセーブ
				var fileName:String;
				var fileData:ByteArray;
				var ze:ZipEntry;

				var zipOut:ZipOutput = new ZipOutput();
				{
					{//Result
						fileName = "Result.png";
						fileData = (new PNGEncoder()).encode(canvas_result.Get_BitmapData_Anim());
						ze = new ZipEntry(fileName);

						zipOut.putNextEntry(ze);
						zipOut.write(fileData);
						zipOut.closeEntry();
					}

					{//Index : Color
						fileName = "Index_Anim_Color.png";
						fileData = (new PNGEncoder()).encode(canvas_result.Get_BitmapData_Index_Anim_Color());
						ze = new ZipEntry(fileName);

						zipOut.putNextEntry(ze);
						zipOut.write(fileData);
						zipOut.closeEntry();
					}

					{//Index : Shade
						fileName = "Index_Anim_Shade.png";
						fileData = (new PNGEncoder()).encode(canvas_result.Get_BitmapData_Index_Anim_Shade());
						ze = new ZipEntry(fileName);

						zipOut.putNextEntry(ze);
						zipOut.write(fileData);
						zipOut.closeEntry();
					}

					var list_h:Array;
					var list_s:Array;
					var list_b:Array;
					var list_a:Array;
					var list:Array;
					var i:int;
					var info:Object;

					{//Palette : Color
						//セーブ情報
						var palette_color:Object;
						{
							list = new Array(info_color.length);
							{
								for(i = 0; i < info_color.length; i++){
									info = {};
									{
										info[palette_hl_color.GetInfoKeyName_Y()] = palette_hl_color.GetVal(i, false);
										info[palette_hl_color.GetInfoKeyName_X()] = palette_hl_color.GetVal(i);
										info[palette_s_color.GetInfoKeyName_X()]  = palette_s_color.GetVal(i);
										info[palette_a_color.GetInfoKeyName_X()]  = palette_a_color.GetVal(i);
									}

									list[i] = info;
								}
							}

							palette_color = list;
						}

						fileName = "Palette_Color.yaml";
						fileData = new ByteArray();
						fileData.writeUTFBytes(YAML.encode(palette_color));
						ze = new ZipEntry(fileName);

						zipOut.putNextEntry(ze);
						zipOut.write(fileData);
						zipOut.closeEntry();
					}

					{//Palette : Shade
						//セーブ情報
						var palette_shade:Object;
						{
							list = new Array(info_shade.length);
							{
								for(i = 0; i < info_shade.length; i++){
									info = {};
									{
										info[palette_hl_shade.GetInfoKeyName_Y()] = palette_hl_shade.GetVal(i, false);
										info[palette_hl_shade.GetInfoKeyName_X()] = palette_hl_shade.GetVal(i);
										info[palette_s_shade.GetInfoKeyName_X()]  = palette_s_shade.GetVal(i);
										info[palette_a_shade.GetInfoKeyName_X()]  = palette_a_shade.GetVal(i);
									}

									list[i] = info;
								}
							}

							palette_shade = list;
						}

						fileName = "Palette_Shade.yaml";
						fileData = new ByteArray();
						fileData.writeUTFBytes(YAML.encode(palette_shade));
						ze = new ZipEntry(fileName);

						zipOut.putNextEntry(ze);
						zipOut.write(fileData);
						zipOut.closeEntry();
					}

					zipOut.finish();
				}

				(new FileReference).save(zipOut.byteArray, "Result.zip");
			}

			//Save : Result
			private function Save_Result():void{
				(new FileReference).save((new PNGEncoder()).encode(canvas_result.m_BitmapData_Anim), "Result.png");
			}


			//Load : All
			private function Load_All():void{
				var fr:FileReference = new FileReference();

				//Select => Load
				fr.addEventListener(
					Event.SELECT,//ファイルが選択されたら
					function(e:Event):void{
						//拡張子をチェックして
						{
							if(fr.name.indexOf(".zip") < 0){//チェックとしては不十分だけどまぁよし
								//err
								return;
							}
						}

						//ロード開始
						{
							fr.load();
						}
					}
				);

				//Load Func
				//var load:Object = {};
				{
					ResetLoadFunc();
				}

				//Load => Draw
				fr.addEventListener(
					Event.COMPLETE,
					function(e:Event):void{
						Load_FromZip(fr.data);
					}
				);

				//実行
				fr.browse();
			}

			public var m_LoadFunc:Object;

			private function ResetLoadFunc():void{
				//Check
				{
					if(m_LoadFunc){
						return;
					}
				}

				//Init
				{
					m_LoadFunc = {};
				}

				//Add Func
				{
					//全てのロードが終了した時の処理のためのアレコレ
					var LoadCount:int = 0;
					var onNewLoad:Function = function():void{
						LoadCount++;
					}
					var onNewLoadEnd:Function = function():void{
						LoadCount--;
						if(LoadCount <= 0){
							//Refresh

							//合成キャンバス：Index => Color
							merge_to_result_all();
							//合成キャンバス→各キャンバス
							canvas_result.onSelected();

							//セーブ画面にも反映
							if(save_palette_c_color){
								Copy_Ori2Save_Canvas_C();
								Copy_Ori2Save_Canvas_S();
								Copy_Ori2Save_Palette_C();
								Copy_Ori2Save_Palette_S();
								Copy_Ori2Save_Canvas_Result();
							}
						}
					}

					//ファイル名に対応するロード処理
/*
					load["Index_Color.png"] = function(i_Data:ByteArray):void{
						var loader:Loader = new Loader();
						loader.loadBytes(i_Data);
						onNewLoad();

						loader.contentLoaderInfo.addEventListener(
							Event.COMPLETE,
							function(e:Event):void{
								canvas_color.m_BitmapData_Index.draw(loader.content);
								canvas_color.Redraw();

								//さらに履歴をリセット
//								ResetHistory_C();
								AddHistory_C();

								onNewLoadEnd();
							}
						);
					};

					load["Index_Shade.png"] = function(i_Data:ByteArray):void{
						var loader:Loader = new Loader();
						loader.loadBytes(i_Data);
						onNewLoad();

						loader.contentLoaderInfo.addEventListener(
							Event.COMPLETE,
							function(e:Event):void{
								canvas_shade.m_BitmapData_Index.draw(loader.content);
								canvas_shade.Redraw();

								//さらに履歴をリセット
//								ResetHistory_S();
								AddHistory_S();

								onNewLoadEnd();
							}
						);
					};
//*/
					//Index : Anim : Color
					m_LoadFunc["Index_Anim_Color.png"] = function(i_Data:ByteArray):void{
						var loader:Loader = new Loader();
						loader.loadBytes(i_Data);
						onNewLoad();

						loader.contentLoaderInfo.addEventListener(
							Event.COMPLETE,
							function(e:Event):void{
								canvas_result.Set_BitmapData_Index_Anim_Color(loader.content);

								onNewLoadEnd();
							}
						);
					};


					//Index : Anim : Shade
					m_LoadFunc["Index_Anim_Shade.png"] = function(i_Data:ByteArray):void{
						var loader:Loader = new Loader();
						loader.loadBytes(i_Data);
						onNewLoad();

						loader.contentLoaderInfo.addEventListener(
							Event.COMPLETE,
							function(e:Event):void{
								canvas_result.Set_BitmapData_Index_Anim_Shade(loader.content);

								onNewLoadEnd();
							}
						);
					};

					m_LoadFunc["Palette_Color.yaml"] = function(i_Data:ByteArray):void{
						var i:int;
						var j:int;
						var len:int = info_color.length;

						var yaml_str:String = i_Data.toString();
						var yaml_map:Object = YAML.decode(yaml_str);

						for(i = 0; i < len; i++){
							info_color[i][palette_hl_color.GetInfoKeyName_Y()] = yaml_map[i][palette_hl_color.GetInfoKeyName_Y()];
							info_color[i][palette_hl_color.GetInfoKeyName_X()] = yaml_map[i][palette_hl_color.GetInfoKeyName_X()];
							info_color[i][palette_s_color.GetInfoKeyName_X()]  = yaml_map[i][palette_s_color.GetInfoKeyName_X()];
							info_color[i][palette_a_color.GetInfoKeyName_X()]  = yaml_map[i][palette_a_color.GetInfoKeyName_X()];
						}

						palette_hl_color.reset(info_color);//onReset => resetの連鎖で初期化
					};

					m_LoadFunc["Palette_Shade.yaml"] = function(i_Data:ByteArray):void{
						var i:int;
						var j:int;
						var len:int = info_shade.length;

						var yaml_str:String = i_Data.toString();
						var yaml_map:Object = YAML.decode(yaml_str);

						for(i = 0; i < len; i++){
							info_shade[i][palette_hl_shade.GetInfoKeyName_Y()] = yaml_map[i][palette_hl_shade.GetInfoKeyName_Y()];
							info_shade[i][palette_hl_shade.GetInfoKeyName_X()] = yaml_map[i][palette_hl_shade.GetInfoKeyName_X()];
							info_shade[i][palette_s_shade.GetInfoKeyName_X()]  = yaml_map[i][palette_s_shade.GetInfoKeyName_X()];
							info_shade[i][palette_a_shade.GetInfoKeyName_X()]  = yaml_map[i][palette_a_shade.GetInfoKeyName_X()];
						}

						palette_hl_shade.reset(info_shade);//onReset => resetの連鎖で初期化
					};
				}
			}

			private function Load_FromZip(in_ZipData:IDataInput):void{
				ResetLoadFunc();

				var zip:ZipFile = new ZipFile(in_ZipData);

				for(var i:int = 0; i < zip.entries.length; i++){
					var entry:ZipEntry = zip.entries[i];
					var zd:ByteArray = zip.getInput(entry);

					if(m_LoadFunc[entry.name]){
						m_LoadFunc[entry.name](zd);
					}
				}
			}

/*
			//Load : Palette : Color
			private function Load_Palette_C():void{
				var fr:FileReference = new FileReference();

				//Select => Load
				fr.addEventListener(
					Event.SELECT,//ファイルが選択されたら
					function(e:Event):void{fr.load();}//ロード開始
				);

				//Load => Set
				fr.addEventListener(
					Event.COMPLETE,
					function(e:Event):void{
						var i:int;
						var j:int;
						var len:int = info_color.length;

						var yaml_str:String = fr.data.toString();
						var yaml_map:Object = YAML.decode(yaml_str);

						for(i = 0; i < len; i++){
							info_color[i][palette_hl_color.GetInfoKeyName_Y()] = yaml_map[i][palette_hl_color.GetInfoKeyName_Y()];
							info_color[i][palette_hl_color.GetInfoKeyName_X()] = yaml_map[i][palette_hl_color.GetInfoKeyName_X()];
							info_color[i][palette_s_color.GetInfoKeyName_X()]  = yaml_map[i][palette_s_color.GetInfoKeyName_X()];
							info_color[i][palette_a_color.GetInfoKeyName_X()]  = yaml_map[i][palette_a_color.GetInfoKeyName_X()];
						}

						palette_hl_color.reset(info_color);//onReset => resetの連鎖で初期化
					}
				);

				//実行
				fr.browse();
			}
//*/
			//Load : Part（一部だけロード）
			private function Load_Part(out_BitmapData:BitmapData):void{
				//Resultのうち、指定した部分だけをロード

				var fr:FileReference = new FileReference();

				//Select => Load
				fr.addEventListener(
					Event.SELECT,//ファイルが選択されたら
					function(e:Event):void{fr.load();}//ロード開始
				);

				//Load => Draw
				fr.addEventListener(
					Event.COMPLETE,
					function(e:Event):void{
						var loader:Loader = new Loader();
						loader.loadBytes(fr.data);

						loader.contentLoaderInfo.addEventListener(
							Event.COMPLETE,
							function(e:Event):void{
								//Set Index Data
								out_BitmapData.draw(loader.content);

								//合成キャンバス：Index => Color
								merge_to_result_all();
								//合成キャンバス→各キャンバス
								canvas_result.onSelected();

								//セーブ画面にも反映
								Copy_Ori2Save_Canvas_C();
								Copy_Ori2Save_Canvas_S();
//								Copy_Ori2Save_Palette_C();
//								Copy_Ori2Save_Palette_S();
								Copy_Ori2Save_Canvas_Result();
							}
						);
					}
				);

				//実行
				fr.browse();
			}


			//==Trace==

			//Set
			private function Trace_Set(in_BitmapData:BitmapData):void{
				if(canvas_result_trace){
					canvas_result_trace.m_Bitmap_Trace.bitmapData = in_BitmapData;
				}

				//メイン側のも変更
				canvas_result.m_Bitmap_Trace.bitmapData = in_BitmapData;

				//さらに「色」キャンバスのも差し替え
				{
					var trace_bmp_data:BitmapData = canvas_result.GetTraceBitmapData();
					if(trace_bmp_data){
						canvas_color.m_Bitmap_Trace.bitmapData = trace_bmp_data;
					}else{
						//ない場合はクリアしても良いか
					}
				}
			}

			//Load
			private function Trace_Load():void{
				var fr:FileReference = new FileReference();

				//Select => Load
				fr.addEventListener(
					Event.SELECT,//ファイルが選択されたら
					function(e:Event):void{fr.load();}//ロード開始
				);

				//Load => Draw
				fr.addEventListener(
					Event.COMPLETE,
					function(e:Event):void{
						var loader:Loader = new Loader();
						loader.loadBytes(fr.data);

						loader.contentLoaderInfo.addEventListener(
							Event.COMPLETE,
							function(e:Event):void{
								var bmp_data:BitmapData = new BitmapData(24*3, 32*4, true, 0x00000000);
								bmp_data.draw(loader.content);

								Trace_Set(bmp_data);
							}
						);
					}
				);

				//実行
				fr.browse();
			}

			//Clear
			private function Trace_Clear():void{
				canvas_result_trace.m_Bitmap_Trace.bitmapData = null;
				canvas_result.m_Bitmap_Trace.bitmapData = null;
				canvas_color.m_Bitmap_Trace.bitmapData = null;
			}
		]]>
	</mx:Script>

	<!--Style-->
	<mx:Style source="style.css"/>

	<!--Tab-->
	<mx:TabNavigator id="tab_main" width="100%" height="100%" resizeToContent="true">

		<!--======================Draw======================-->

		<mx:HBox id="view_base_draw" label="描画(Draw)" paddingTop="10">
			<!--Space-->
			<mx:Spacer width="100%"/>

			<!--HSBA-->
			<mx:VBox id="area_color_picker" width="0">
				<mx:Panel title="色相・輝度(H_L)">
					<comp:Palette_HL id="palette_hl_color"/>
				</mx:Panel>

				<!--Space-->
				<mx:Spacer height="100%"/>

				<mx:Panel title="彩度(S)">
					<comp:Palette_S  id="palette_s_color"/>
				</mx:Panel>

				<!--Space-->
				<mx:Spacer height="100%"/>

				<mx:Panel title="アルファ(A)">
					<comp:Palette_A  id="palette_a_color"/>
				</mx:Panel>
			</mx:VBox>

			<!--Color-->
			<mx:VBox horizontalAlign="center">
				<mx:Panel title="色(Color)" paddingLeft="20" paddingRight="20">
					<comp:Palette_Color id="palette_c_color"/>
				</mx:Panel>

				<!-- Open&Close Button -->
				<mx:Button id="open_close_button_color" label="色調整" buttonDown="OpenClose_Color();"/>
			</mx:VBox>

			<!--Canvas : Color-->
			<mx:VBox>
				<!--Canvas-->
				<mx:Panel title="履歴(History)" width="100%" layout="horizontal">
					<mx:HBox id="history_color" horizontalScrollPolicy="on" height="48">
					</mx:HBox>
				</mx:Panel>

				<!--Space-->
				<mx:Spacer height="10%"/>

				<!--Canvas-->
				<mx:Panel title="「色」キャンバス(Canvas_Color)" width="100%" layout="horizontal">
					<mx:Box id="box_canvas_color" verticalScrollPolicy="on" horizontalScrollPolicy="on">
						<comp:Canvas_Zoom id="canvas_color"/>
					</mx:Box>
				</mx:Panel>
			</mx:VBox>


			<!--Space-->
			<mx:Spacer width="100%"/>


			<!--Canvas : Result-->
			<mx:VBox>
				<!--Space-->
				<mx:Spacer height="100%"/>

				<!--Setting-->
				<mx:Panel title="設定(Settings)" width="100%" layout="vertical">
					<!--Combo : Size-->
<!--
					<mx:HBox width="100%">
						<mx:Label text="表示サイズ(Size)："/>
						<mx:Spacer width="100%"/>
						<mx:ComboBox id="combo_size" change="Canvas_x(combo_size.value as int)">
							<mx:dataProvider>
								<mx:Array>
									<mx:Object label="x1" data="1" />
									<mx:Object label="x2" data="2" />
									<mx:Object label="x4" data="4" />
									<mx:Object label="x8" data="8" />
								</mx:Array>
							</mx:dataProvider>
						</mx:ComboBox>
					</mx:HBox>
-->

					<!--Combo : Cursor-->
					<mx:HBox width="100%">
						<mx:Label text="カーソル(Cursor)："/>
						<mx:Spacer width="100%"/>
						<mx:ComboBox id="combo_cursor" change="Canvas_SetCursorMode(combo_cursor.selectedItem.data)" dataProvider="{ComboData_Cursor}">
						</mx:ComboBox>
					</mx:HBox>

					<!--Combo : Draw-->
					<mx:HBox width="100%">
						<mx:Label text="描画方法(Draw)："/>
						<mx:Spacer width="100%"/>
						<mx:ComboBox id="combo_draw" change="Canvas_ChangeDrawType(combo_draw.selectedItem.data)" dataProvider="{ComboData_Draw}">
						</mx:ComboBox>
					</mx:HBox>

					<mx:HBox width="100%">
						<mx:Spacer width="100%"/>
						<mx:Grid>
							<mx:GridRow>
								<mx:GridItem horizontalAlign="center"> <mx:Label text="移動"/> </mx:GridItem>
								<mx:GridItem> <mx:Button label="↑" buttonDown="ScrollBitmap( 0, -1)"/> </mx:GridItem>
								<mx:GridItem/>
							</mx:GridRow>
							<mx:GridRow>
								<mx:GridItem> <mx:Button label="←" buttonDown="ScrollBitmap(-1,  0)"/> </mx:GridItem>
								<mx:GridItem> <mx:Button label="⇔" buttonDown="ReverseBitmap()"/> </mx:GridItem>
								<mx:GridItem> <mx:Button label="→" buttonDown="ScrollBitmap( 1,  0)"/> </mx:GridItem>
							</mx:GridRow>
							<mx:GridRow>
								<mx:GridItem/>
								<mx:GridItem> <mx:Button label="↓" buttonDown="ScrollBitmap( 0,  1)"/> </mx:GridItem>
								<mx:GridItem/>
							</mx:GridRow>
						</mx:Grid>
						<mx:Spacer width="100%"/>
					</mx:HBox>
				</mx:Panel>

				<!--Space-->
				<mx:Spacer height="100%"/>

				<!--Canvas-->
				<mx:Panel title="結果(Result)" width="100%">
					<comp:Canvas_Result id="canvas_result"/>
				</mx:Panel>

				<!--Space-->
				<mx:Spacer height="100%"/>
			</mx:VBox>


			<!--Space-->
			<mx:Spacer width="100%"/>


			<!--Canvas : Shade-->
			<mx:VBox>
				<!--Canvas-->
				<mx:Panel title="履歴(History)" width="100%" layout="horizontal">
					<mx:HBox id="history_shade" horizontalScrollPolicy="on" height="48">
					</mx:HBox>
				</mx:Panel>

				<!--Space-->
				<mx:Spacer height="10%"/>

				<!--Canvas-->
				<mx:Panel title="「陰」キャンバス(Canvas_Shade)" width="100%" layout="horizontal">
					<mx:Box id="box_canvas_shade" verticalScrollPolicy="on" horizontalScrollPolicy="on">
						<comp:Canvas_Zoom id="canvas_shade"/>
					</mx:Box>
				</mx:Panel>
			</mx:VBox>

			<!--Color of Shade-->
			<mx:VBox horizontalAlign="center">
				<mx:Panel title="光陰(Shade)" paddingLeft="20" paddingRight="20">
					<comp:Palette_Color id="palette_c_shade"/>
				</mx:Panel>

				<!-- Open&Close Button -->
				<mx:Button id="open_close_button_shade" label="光陰調整" buttonDown="OpenClose_Shade();"/>
			</mx:VBox>

			<!--HSBA of Shade-->
			<mx:VBox id="area_shade_picker" width="0">
				<mx:Panel title="色相・彩度(H_S)">
					<comp:Palette_HL id="palette_hl_shade"/>
				</mx:Panel>

				<!--Space-->
				<mx:Spacer height="100%"/>

				<mx:Panel title="輝度(L)"><!--Old:明度(B)-->
					<comp:Palette_S  id="palette_s_shade"/>
				</mx:Panel>

				<!--Space-->
				<mx:Spacer height="100%"/>

				<mx:Panel title="アルファ(A)">
					<comp:Palette_A  id="palette_a_shade"/>
				</mx:Panel>
			</mx:VBox>

			<!--Space-->
			<mx:Spacer width="100%"/>
		</mx:HBox>


		<!--======================Save======================-->

		<mx:HBox id="tab_save_file" label="ファイル(File)">
			<mx:Spacer width="100%"/>

			<!--Palette : Color-->
			<mx:VBox height="100%" width="0"><!--まだ使用していないので隠す-->
				<mx:Spacer height="100%"/>
				<mx:Panel title="色(Color)" paddingLeft="20" paddingRight="20">
<!--
					<mx:Button label="↓ロード(Load)" buttonDown="Load_C_Palette()"/>
-->
					<mx:Spacer height="5"/>
					<comp:Palette_Color id="save_palette_c_color" render="Copy_Ori2Save_Palette_C()"/>
					<mx:Spacer height="5"/>
<!--
					<mx:Button label="↓セーブ(Save)" buttonDown="Save_C_Palette()"/>
-->
				</mx:Panel>
				<mx:Spacer height="100%"/>
			</mx:VBox>

			<mx:Spacer width="100%"/>

			<!--Canvas : Color-->
			<mx:VBox height="100%" width="0"><!--過去のエディタからの引き継ぎでもない限り使わないので隠す-->
				<mx:Spacer height="100%"/>
				<mx:Panel title="「色」キャンバス(Canvas_Color)">
					<mx:Button label="部分ロード：色" buttonDown="Load_Part(canvas_result.m_BitmapData_Index_Anim_Color[save_canvas_result.m_CursorIndex]);"/>
<!--
					<mx:Button label="↓ロード(Load)" buttonDown="Load_C_Index()"/>
-->
					<mx:Spacer height="5"/>
					<comp:Canvas_Zoom id="save_canvas_color" render="Copy_Ori2Save_Canvas_C()"/>
					<mx:Spacer height="5"/>
<!--
					<mx:Button label="↓セーブ(Save)" buttonDown="Save_C_Index()"/>
					<mx:Spacer height="5"/>
					<mx:Button label="↓セーブ：画像として(Save as Graphic)" buttonDown="Save_C()"/>
-->
				</mx:Panel>
				<mx:Spacer height="100%"/>
			</mx:VBox>

			<mx:Spacer width="100%"/>

			<!--Center-->
			<mx:VBox height="100%" horizontalAlign="center">
				<mx:Spacer height="100%"/>

				<mx:Panel title="まとめて(Zip)" horizontalAlign="center">
					<!--Load : All-->
					<mx:Button label="まとめてロード(Load:Zip)" buttonDown="Load_All()"/>
				</mx:Panel>

				<mx:Spacer height="100%"/>

				<mx:Panel title="結果(Result)" horizontalAlign="center">

					<mx:Spacer height="5"/>

					<comp:Canvas_Result id="save_canvas_result" render="Copy_Ori2Save_Canvas_Result(); save_canvas_result.onSelected=onSaveCanvasSelected"/>

					<mx:Spacer height="5"/>

					<!--Save : Result-->
					<mx:Button label="結果だけセーブ(Save:Result)" buttonDown="Save_Result()"/>
				</mx:Panel>

				<mx:Spacer height="100%"/>

				<mx:Panel title="まとめて(Zip)" horizontalAlign="center">
					<!--Save : All-->
					<mx:Button label="まとめてセーブ(Save:Zip)" buttonDown="Save_All()"/>
				</mx:Panel>

				<mx:Spacer height="100%"/>
			</mx:VBox>

			<mx:Spacer width="100%"/>

			<!--Canvas : Shade-->
			<mx:VBox height="100%" width="0"><!--過去のエディタからの引き継ぎでもない限り使わないので隠す-->
				<mx:Spacer height="100%"/>
				<mx:Panel title="「陰」キャンバス(Canvas_Shade)">
					<mx:Button label="部分ロード：陰" buttonDown="Load_Part(canvas_result.m_BitmapData_Index_Anim_Shade[save_canvas_result.m_CursorIndex]);"/>
<!--
					<mx:Button label="↓ロード(Load)" buttonDown="Load_S_Index()"/>
-->
					<mx:Spacer height="5"/>
					<comp:Canvas_Zoom id="save_canvas_shade" render="Copy_Ori2Save_Canvas_S()"/>
					<mx:Spacer height="5"/>
<!--
					<mx:Button label="↓セーブ(Save)" buttonDown="Save_S_Index()"/>
					<mx:Spacer height="5"/>
					<mx:Button label="↓セーブ：画像として(Save as Graphic)" buttonDown="Save_S()"/>
-->
				</mx:Panel>
				<mx:Spacer height="100%"/>
			</mx:VBox>

			<mx:Spacer width="100%"/>

			<!--Palette : Shade-->
			<mx:VBox height="100%" width="0"><!--まだ使用していないので隠す-->
				<mx:Spacer height="100%"/>
				<mx:Panel title="光陰(Shade)" paddingLeft="20" paddingRight="20">
<!--
					<mx:Button label="↓ロード(Load)" buttonDown="Load_S_Palette()"/>
-->
					<mx:Spacer height="5"/>
					<comp:Palette_Color id="save_palette_c_shade" render="Copy_Ori2Save_Palette_S()"/>
					<mx:Spacer height="5"/>
<!--
					<mx:Button label="↓セーブ(Save)" buttonDown="Save_S_Palette()"/>
-->
				</mx:Panel>
				<mx:Spacer height="100%"/>
			</mx:VBox>

			<mx:Spacer width="100%"/>
		</mx:HBox>


		<!--======================Drawed======================-->
		<mx:HBox id="tab_save_target" label="描画対象(Drawed)">
			<mx:Spacer width="100%"/>

			<mx:VBox height="100%">
				<mx:Spacer height="100%"/>

				<mx:Panel title="描画してあるものを別の場所にコピー" layout="horizontal">
					<mx:Panel title="コピー元(SRC)" layout="vertical">
						<comp:Canvas_Result id="canvas_result_drawed_src" render="CopyGraphic_CanvasResult(canvas_result, canvas_result_drawed_src)"/>
					</mx:Panel>

					<mx:VBox height="100%">
						<mx:Spacer height="100%"/>
						<mx:Button label="→コピー(Copy)" buttonDown="Copy_SrcIndex_to_DstIndex(canvas_result_drawed_src.m_CursorIndex, canvas_result_drawed_dst.m_CursorIndex)"/>
						<mx:Spacer height="100%"/>
					</mx:VBox>

					<mx:Panel title="コピー先(DST)" layout="vertical">
						<comp:Canvas_Result id="canvas_result_drawed_dst" render="CopyGraphic_CanvasResult(canvas_result, canvas_result_drawed_dst)"/>
					</mx:Panel>
				</mx:Panel>

				<mx:Spacer height="100%"/>
			</mx:VBox>

			<mx:Spacer width="100%"/>
		</mx:HBox>

		<!--======================Trace======================-->

		<mx:HBox id="tab_save_trace" label="トレース(Trace)">
			<mx:Spacer width="100%"/>

			<!--Palette : Color-->
			<mx:VBox height="100%">
				<mx:Spacer height="100%"/>
				<mx:Panel title="全体(All)" layout="vertical">
					<mx:Button label="↓ロード(Load)" buttonDown="Trace_Load()"/>
					<comp:Canvas_Result id="canvas_result_trace" render="Copy_Ori2Trace()"/>
					<mx:Button label="クリア(Clear)" buttonDown="Trace_Clear()"/>
				</mx:Panel>
				<mx:Spacer height="100%"/>
			</mx:VBox>

			<mx:Spacer width="100%"/>
		</mx:HBox>
	</mx:TabNavigator>
</mx:Application>
